# nvs和工具函数

# nvs

详见:

 [32_Drive/ESP32/nvs at main · gybpersist/32_Drive](https://github.com/gybpersist/32_Drive/tree/main/ESP32/nvs) 

## Dri_nvs.c

```c
#include "Dri_nvs.h"

nvs_handle_t my_handle;

/**
 * @brief 初始化 nvs
 *
 */
void Dri_nvs_Init(void)
{
    // 初始化 NVS
    esp_err_t err = nvs_flash_init();
    if (err == ESP_ERR_NVS_NO_FREE_PAGES || err == ESP_ERR_NVS_NEW_VERSION_FOUND)
    {
        ESP_ERROR_CHECK(nvs_flash_erase());
        err = nvs_flash_init();
    }
    ESP_ERROR_CHECK(err);

    // Open
    printf("\n");
    printf("Opening Non-Volatile Storage (NVS) handle... ");
    err = nvs_open("storage", NVS_READWRITE, &my_handle);
}

/**
 * @brief 查找键
 *
 * @param key 键
 * @return esp_err_t 错误信息
 */
esp_err_t Dri_nvs_FindKey(char *key)
{
    esp_err_t err = nvs_find_key(my_handle, key, NULL);
    return err;
}

/**
 * @brief 增加键值对
 *
 * @param key 键
 * @param value 值
 */
void Dri_nvs_AddKey(char *key, char *value)
{
    nvs_set_str(my_handle, key, value);
}

/**
 * @brief 获取键值对
 *
 * @param key 键
 * @param out_value 获取键的值
 * @param length 值长度
 */
void Dri_nvs_GetKey(char *key, char *out_value, size_t *length)
{
    nvs_get_str(my_handle, key, out_value, length);
}
```

## Dri_nvs.h

```c
#ifndef __DRI_NVS_H__
#define __DRI_NVS_H__

#include <stdio.h>
#include <inttypes.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_system.h"
#include "nvs_flash.h"
#include "nvs.h"

/**
 * @brief 初始化 nvs
 * 
 */
void Dri_nvs_Init(void);

/**
 * @brief 查找键
 * 
 * @param key 键
 * @return esp_err_t 错误信息 
 */
esp_err_t Dri_nvs_FindKey(char *key);

/**
 * @brief 增加键值对
 * 
 * @param key 键
 * @param value 值
 */
void Dri_nvs_AddKey(char *key, char *value);

/**
 * @brief 获取键值对
 * 
 * @param key 键
 * @param out_value 获取键的值
 * @param length 值长度
 */
void Dri_nvs_GetKey(char *key, char *out_value, size_t *length);

#endif /* __DRI_NVS_H__ */
```

## 工具函数

可变缓冲区 获取WiFi的MAC地址 生成UUID

## Com_Util.c

```c
#include "Com_Util.h"

// 定义 可变缓冲区
struct mutable_buffer
{
    char *data;
    size_t data_len;
};

/**
 * @brief 创建 可变缓冲区对象
 *
 * @return mutable_buffer_t* 可变缓冲区对象
 */
mutable_buffer_t *Com_MutableBuffer_Creat(void)
{
    // 创建 可变缓冲区对象
    mutable_buffer_t *mutable_buffer = (mutable_buffer_t *)heap_caps_malloc(sizeof(mutable_buffer_t), MALLOC_CAP_SPIRAM);
    if (mutable_buffer != NULL)
    {
        mutable_buffer->data = NULL;
        mutable_buffer->data_len = 0;
    }

    // 返回 可变缓冲区对象
    return mutable_buffer;
}

void Com_MutableBuffer_AddData(mutable_buffer_t *mutable_buffer, char *data, size_t data_len)
{
    // 1. 输入参数有效性检查（避免非法输入）
    assert(mutable_buffer);
    // 若 data 为 NULL，data_len 必须为 0（否则无数据可拷贝）
    if (data == NULL && data_len > 0)
    {
        MY_LOGE("Invalid input: data is NULL but data_len > 0");
        return;
    }

    char *new_data = NULL;
    size_t new_len = mutable_buffer->data_len + data_len; // 新的有效数据总长度

    // 2. 分配/重分配内存
    if (mutable_buffer->data == NULL)
    {
        // 首次使用：分配 "新数据长度 + 1" 的内存
        new_data = heap_caps_malloc(new_len + 1, MALLOC_CAP_SPIRAM);
    }
    else
    {
        // 非首次：扩展内存（保留原有数据，新大小 = 原有数据 + 新数据 + 1）
        new_data = heap_caps_realloc(
            mutable_buffer->data, // 原有内存指针（realloc 会自动处理原有数据拷贝）
            new_len + 1,          // 修正：新内存大小 = 总有效数据 + \0
            MALLOC_CAP_SPIRAM);
    }

    // 3. 关键：检查内存分配是否成功（避免空指针）
    if (new_data == NULL)
    {
        // 分配失败：保留原有缓冲区数据，不覆盖（避免数据丢失）
        MY_LOGE("Failed to allocate SPI RAM: new_mem_size = %zu", new_len + 1);
        return;
    }

    // 4. 拷贝新数据到缓冲区末尾（仅当有数据可拷贝时）
    if (data_len > 0)
    {
        memcpy(
            new_data + mutable_buffer->data_len, // 目标地址：原有数据的末尾
            data,                                // 源地址：传入的新数据
            data_len                             // 拷贝长度：本次新数据的长度
        );
    }

    // 5. 更新缓冲区状态（确保数据完整和安全）
    mutable_buffer->data = new_data;      // 指向新分配的内存
    mutable_buffer->data_len = new_len;   // 更新有效数据长度
    mutable_buffer->data[new_len] = '\0'; // 添加字符串结束符（避免越界访问）
}

void *Com_MutableBuffer_GetData(mutable_buffer_t *mutable_buffer)
{
    assert(mutable_buffer);
    return mutable_buffer->data;
}

void Com_MutableBuffer_Free(mutable_buffer_t *mutable_buffer)
{
    // 检查缓冲区指针有效性
    assert(mutable_buffer);

    // 释放数据缓冲区（使用 heap_caps_free 匹配分配函数）
    if (mutable_buffer->data != NULL)
    {
        heap_caps_free(mutable_buffer->data); // 正确释放 SPI RAM 内存
        mutable_buffer->data = NULL;          // 置空指针，避免野指针
        mutable_buffer->data_len = 0;         // 重置长度
    }

    // 不释放 mutable_buffer 本身（由调用者管理其生命周期）
}

char *mac_addr = NULL;
char *uuid = NULL;

/**
 * 获取WIFI的 mac地址
 */
char *Com_Get_MAC(void)
{
    // 如果已经有mac地址了直接返回
    if (mac_addr != NULL)
    {
        return mac_addr;
    }

    // 没有就获取
    uint8_t eth_mac[6] = {0};
    // WIFI_IF_STA：表示 Station 模式接口，即 ESP32 作为客户端连接到其他 Wi-Fi 热点
    esp_wifi_get_mac(WIFI_IF_STA, eth_mac);
    mac_addr = heap_caps_malloc(18, MALLOC_CAP_SPIRAM);
    // "%02X:%02X:%02X:%02X:%02X:%02X",
    snprintf(mac_addr,18,
             "%02x:%02x:%02x:%02x:%02x:%02x",
             eth_mac[0], eth_mac[1], eth_mac[2], eth_mac[3], eth_mac[4], eth_mac[5]);

    return mac_addr;
}

/**
 * @brief 获取一个UUID
 *
 * @return char* 获取到的UUID
 */
char *Com_Get_UUID(void)
{
    if (uuid != NULL)
    {
        return uuid;
    }

    uuid = heap_caps_malloc(37, MALLOC_CAP_SPIRAM);

    // 从FLASH中查询UUID是否存在
    if (Dri_nvs_FindKey(UUID_KEY) == ESP_OK)
    {
        size_t len = 37;
        Dri_nvs_GetKey(UUID_KEY, uuid, &len);
        return uuid;
    }

    // 如果不存在,则随机生成一个UUID
    unsigned char bytes[16];
    for (int i = 0; i < 16; i++)
    {
        bytes[i] = rand() % 256;
    }

    // 设置版本号（版本4）
    bytes[6] = (bytes[6] & 0x0F) | 0x40; // 设置版本为4
    bytes[8] = (bytes[8] & 0x3F) | 0x80; // 设置变体为10

    // 格式化为UUID字符串
    sprintf(uuid,
            "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
            bytes[0], bytes[1], bytes[2], bytes[3],
            bytes[4], bytes[5], bytes[6], bytes[7],
            bytes[8], bytes[9], bytes[10], bytes[11],
            bytes[12], bytes[13], bytes[14], bytes[15]);

    // 将生成的UUID保存到FLASH中
    Dri_nvs_AddKey(UUID_KEY, uuid);

    // 返回结果
    return uuid;
}

```

 ## Com_Util.h

```c
#ifndef __COM_UTIL_H__
#define __COM_UTIL_H__

#include "esp_heap_caps.h"
#include "string.h"
#include "stddef.h"
#include "assert.h"
#include "Com_Debug.h"
#include <esp_wifi.h>
#include "Dri_nvs.h"

#define UUID_KEY "UUID"

/**
 * 获取WIFI的 mac地址
 */
char *Com_Get_MAC(void);

/**
 * @brief 获取一个UUID 
 * 
 * @return char* 获取到的UUID
 */
char *Com_Get_UUID(void);

// 定义 可变缓冲区
typedef struct mutable_buffer mutable_buffer_t;

/**
 * @brief 创建 可变缓冲区对象
 * 
 * @return mutable_buffer_t* 可变缓冲区对象
 */
mutable_buffer_t *Com_MutableBuffer_Creat(void);

void Com_MutableBuffer_AddData(mutable_buffer_t *mutable_buffer,char *data,size_t data_len);

void *Com_MutableBuffer_GetData(mutable_buffer_t *mutable_buffer);

void Com_MutableBuffer_Free(mutable_buffer_t *mutable_buffer);

#endif /* __COM_UTIL_H__ */
```

